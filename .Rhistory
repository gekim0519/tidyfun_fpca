LEFT JOIN (
SELECT DISTINCT customer_id, MIN(date) AS first_date
FROM Web_sessions
GROUP BY customer_id
) AS t2 ON t1.date = t2.first_date
GROUP BY date;
")
sqldf("SELECT t1.date, COUNT(*) AS session_counts, COUNT(CASE WHEN t1.has_conversion = 'TRUE' then 1 end) as conversions, COUNT(t2.customer_id) AS new_customers
FROM Web_sessions AS t1
LEFT JOIN (
SELECT DISTINCT customer_id, MIN(date) AS first_date
FROM Web_sessions
GROUP BY customer_id
) AS t2 ON t1.date = t2.first_date
GROUP BY date;
")
sqldf("SELECT t1.date, COUNT(*) AS session_counts, COUNT(CASE WHEN t1.has_conversion = 'TRUE' then 1 end) as conversions, COUNT(t2.customer_id) AS new_customers
FROM Web_sessions AS t1
LEFT JOIN (
SELECT DISTINCT customer_id, MIN(date) AS first_date
FROM Web_sessions
GROUP BY customer_id
) AS t2 ON t1.date = t2.first_date
GROUP BY date;
")
knitr::opts_chunk$set(echo = TRUE)
library(tidyfun)
library(tidyverse)
library(ggplot2)
library(refund)
library(reshape2)
# cursive handwriting coordinates
#load data
load("../data/handwrit.rda")
handwrit_time <- handwritTime %>% as.tibble() %>%
janitor::clean_names()
rm(handwritTime)
handwrit <- handwrit %>%
as.tibble() %>%
janitor::clean_names()
plot(handwrit$rep01_x, handwrit$rep01_y, type="l")
plot(handwrit$rep02_x, handwrit$rep02_y, type="l")
hw_x = handwrit %>%
as.matrix() %>%
.[,1:20] %>%
t()
hw_y = handwrit %>%
as.matrix() %>%
.[,21:40] %>%
t()
handw_tfd = data.frame(id = 1:20) %>%
as.tbl %>%
mutate(x = tfd(hw_x),
y = tfd(hw_y))
handw_tfd %>%
filter(id == 1) %>%
ggplot(aes(y = y)) +
geom_spaghetti()
load("../data/CanadianWeather.rda")
cwtemp = CanadianWeather[[1]] %>% as.tibble() %>%
t() %>% as.matrix() %>%
.[1:35,]
place = c(CanadianWeather$place)
temp_df = data.frame(place = CanadianWeather$place)
temp_df$temp = cwtemp
temp_tfd = with(temp_df,
data.frame(place = place)) %>% as.tbl %>%
mutate(temp = tfd(temp_df$temp))
# tfd(temp_df$temp)) (1, -4) to jan1, -4?
temp_tfd %>%
filter(place == "Halifax") %>%
ggplot(aes(y = temp)) +
geom_spaghetti() +
ggtitle(label = "Average daily temperature for each day of the year in Halifax")
temp_tfd %>%
filter(place %in% c("Quebec", "Vancouver")) %>%
ggplot(aes(y = temp, color = place)) +
geom_spaghetti(alpha = .3) +
geom_meatballs(aes(alpha = .5)) +
facet_grid(~ place)
save(temp_tfd, file = "../data/temp_tdf.RData")
save(handw_tfd, file = "../data/handw_tdf.RData")
# tidyfun example
DTI = refund::DTI
dti = with(refund::DTI,
data.frame(id = ID, sex = sex,
case = factor(ifelse(case, "MS", "control")))) %>% as.tbl %>%
mutate(cca = tfd(DTI$cca, seq(0,1, l = 93), signif = 2) %>%
tfd(arg = seq(0,1,l = 93)),
rcst = tfd(DTI$rcst, seq(0, 1, l = 55), signif = 3))
dti %>%
filter(id == 2031)
data(cd4)
# CD4 cell counts for 366 subjects between months -18 and 42 since seroconversion. Each subject's observations are contained in a single row.
# subject * weeks
Fit.MM = fpca.sc(cd4, var = TRUE, simul = TRUE)
Fit.mu = data.frame(mu = Fit.MM$mu,
d = as.numeric(colnames(cd4)))
Fit.basis = data.frame(phi = Fit.MM$efunctions, # d Ã— npc matrix of estimated eigenfunctions of the functional covariance, i.e., the FPC basis functions.
d = as.numeric(colnames(cd4)))
## for one subject, examine curve estimate, pointwise and simultaneous itervals
EX = 1
EX.MM = data.frame(fitted = Fit.MM$Yhat[EX,],
ptwise.UB = Fit.MM$Yhat[EX,] + 1.96 * sqrt(Fit.MM$diag.var[EX,]),
ptwise.LB = Fit.MM$Yhat[EX,] - 1.96 * sqrt(Fit.MM$diag.var[EX,]),
simul.UB = Fit.MM$Yhat[EX,] + Fit.MM$crit.val[EX] * sqrt(Fit.MM$diag.var[EX,]),
simul.LB = Fit.MM$Yhat[EX,] - Fit.MM$crit.val[EX] * sqrt(Fit.MM$diag.var[EX,]),
d = as.numeric(colnames(cd4)))
## plot data for one subject, with curve and interval estimates
EX.MM.m = melt(EX.MM, id = 'd')
ggplot(EX.MM.m, aes(x = d, y = value, group = variable, color = variable, linetype = variable)) +
geom_path() +
scale_linetype_manual(values = c(fitted = 1, ptwise.UB = 2,
ptwise.LB = 2, simul.UB = 3, simul.LB = 3)) +
scale_color_manual(values = c(fitted = 1, ptwise.UB = 2,
ptwise.LB = 2, simul.UB = 3, simul.LB = 3)) +
labs(x = 'Months since seroconversion', y = 'Total CD4 Cell Count')
## plot estimated mean function
ggplot(Fit.mu, aes(x = d, y = mu)) + geom_path() +
labs(x = 'Months since seroconversion', y = 'Total CD4 Cell Count')
## plot the first two estimated basis functions
Fit.basis.m = melt(Fit.basis, id = 'd')
ggplot(subset(Fit.basis.m, variable %in% c('phi.1', 'phi.2')), aes(x = d,
y = value, group = variable, color = variable)) + geom_path()
## input a dataframe instead of a matrix
nid <- 20
nobs <- sample(10:20, nid, rep=TRUE)
ydata <- data.frame(
.id = rep(1:nid, nobs),
.index = round(runif(sum(nobs), 0, 1), 3)) # long format
ydata$.value <- unlist(tapply(ydata$.index,
ydata$.id,
function(x)
runif(1, -.5, .5) +
dbeta(x, runif(1, 6, 8), runif(1, 3, 5))
)
)
Fit.MM = fpca.sc(ydata=ydata, var = TRUE, simul = FALSE)
fit.cw = fpca.sc(cwtemp, var = TRUE, simul = TRUE)
fit.mu = data.frame(mu = fit.cw$mu,
days = 1:365)
fit.basis = data.frame(phi = fit.cw$efunctions, #the FPC basis functions.
days = 1:365)
temp_tfd %>%
ggplot(aes(y = temp, color = place)) +
geom_spaghetti(alpha = .3) + xlab("days") + theme(legend.position="none")
## plot the first two estimated basis functions
fit.basis.m = melt(fit.basis, id = 'days')
ggplot(subset(fit.basis.m, variable %in% c('phi.1', 'phi.2')), aes(x = days,
y = value, group = variable, color = variable)) + geom_path() + ggtitle("first two estimated basis functions")
## plot estimated mean function
ggplot(fit.mu, aes(x = days, y = mu)) + geom_path() +
labs(x = 'Day', y = 'Average daily temperature')
# estimated eigenvalues of the covariance operator, i.e., variances of FPC scores.
fit.cw$evalues
fit.cw$evalues*100/sum(fit.cw$evalues)
# rcst A 382 x 55 matrix of fractional anisotropy tract profiles from the right corticospinal tract;
rcst <- dti$rcst %>%
as.data.frame() %>%
spread(key = arg, value = value) %>%
select(-id) %>%
as.matrix()
fit.rcst = fpca.sc(rcst, var = TRUE, simul = TRUE)
# df
rcst_df <- dti$rcst %>%
as.data.frame() %>%
select(.id = id, .index = arg, .value = value) %>%
mutate(.id = as.integer(.id))
knitr::opts_chunk$set(echo = TRUE)
dti %>%
head()
DTI = refund::DTI
dti = with(refund::DTI,
data.frame(id = ID, sex = sex,
case = factor(ifelse(case, "MS", "control")))) %>% as.tbl %>%
mutate(cca = tfd(DTI$cca, seq(0,1, l = 93), signif = 2) %>%
tfd(arg = seq(0,1,l = 93)),
rcst = tfd(DTI$rcst, seq(0, 1, l = 55), signif = 3))
dti %>%
head()
dti %>%
ggplot(aes(y = cca, color = factor(id))) +
geom_spaghetti(alpha = .3) + xlab("days") + theme(legend.position="none")
## input a dataframe instead of a matrix
nid <- 20
nobs <- sample(10:20, nid, rep=TRUE)
ydata <- data.frame(
.id = rep(1:nid, nobs),
.index = round(runif(sum(nobs), 0, 1), 3)) # long format
ydata$.value <- unlist(tapply(ydata$.index,
ydata$.id,
function(x)
runif(1, -.5, .5) +
dbeta(x, runif(1, 6, 8), runif(1, 3, 5))
)
)
Fit.MM = fpca.sc(ydata=ydata, var = TRUE, simul = FALSE)
fit.cw = fpca.sc(cwtemp, var = TRUE, simul = TRUE)
fit.cw = fpca.sc(cwtemp, var = TRUE, simul = TRUE)
fit.mu = data.frame(mu = fit.cw$mu,
days = 1:365)
fit.basis = data.frame(phi = fit.cw$efunctions, #the FPC basis functions.
days = 1:365)
temp_tfd %>%
ggplot(aes(y = temp, color = place)) +
geom_spaghetti(alpha = .3) + xlab("days") + theme(legend.position="none")
dti %>%
ggplot(aes(y = cca, color = factor(id))) +
geom_spaghetti(alpha = .3) + xlab("days") + theme(legend.position="none")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyfun)
library(refund)
library(ggplot2)
library(reshape2)
source("../function/quadWeights.R")
source("../function/fpca.tfd.R")
models = c("dti.ols", "gibbs_dti", "gibbs_dti_wish")
intercepts = sapply(models, function(u) get(u)$beta.hat[1,])
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyfun)
library(refund)
library(ggplot2)
library(reshape2)
source("../function/quadWeights.R")
source("../function/fpca.tfd.R")
temp_tfd = load("../data/temp_tfd.RData")
handw_tfd= load("../data/handw_tfd.RData")
DTI = refund::DTI
dti = with(refund::DTI,
data.frame(id = ID, sex = sex, pasat = pasat,
case = factor(ifelse(case, "MS", "control")))) %>% as.tbl %>%
mutate(cca = tfd(DTI$cca, seq(0,1, l = 93), signif = 2) %>%
tfd(arg = seq(0,1,l = 93)),
rcst = tfd(DTI$rcst, seq(0, 1, l = 55), signif = 3))
fit.cca = fpca.tfd(data = dti, col = cca)
fit.mu = data.frame(mu = fit.cca$mu,
n = 1:ncol(fit.cca$Yhat))
fit.basis = data.frame(phi = fit.cca$efunctions, #the FPC basis functions.
n = 1:ncol(fit.cca$Yhat))
## plot estimated mean function
ggplot(fit.mu, aes(x = n, y = mu)) + geom_path() + theme_bw()
## plot the first two estimated basis functions
fit.basis.m = melt(fit.basis, id = 'n')
ggplot(subset(fit.basis.m, variable %in% c('phi.1', 'phi.2')), aes(x = n,
y = value, group = variable, color = variable)) + geom_path() + theme_bw()
data(cd4)
# CD4 cell counts for 366 subjects between months -18 and 42 since seroconversion. Each subject's observations are contained in a single row.
# subject * weeks
cd4_tfd = cd4 %>%
tfd()
cd4_df = data_frame(cd4_tfd, id = 1:366) %>%
select(cd4 = cd4_tfd, everything())
fit.cd4 = cd4_df %>%
fpca.tfd(data =., col = cd4)
fit.mu = data.frame(mu = fit.cd4$mu,
n = 1:ncol(fit.cd4$Yhat))
fit.basis = data.frame(phi = fit.cd4$efunctions, #the FPC basis functions.
n = 1:ncol(fit.cd4$Yhat))
## for one subject, examine curve estimate, pointwise and simultaneous itervals
EX = 1
EX.MM = data.frame(fitted = Fit.MM$Yhat[EX,],
ptwise.UB = Fit.MM$Yhat[EX,] + 1.96 * sqrt(Fit.MM$diag.var[EX,]),
ptwise.LB = Fit.MM$Yhat[EX,] - 1.96 * sqrt(Fit.MM$diag.var[EX,]),
simul.UB = Fit.MM$Yhat[EX,] + Fit.MM$crit.val[EX] * sqrt(Fit.MM$diag.var[EX,]),
simul.LB = Fit.MM$Yhat[EX,] - Fit.MM$crit.val[EX] * sqrt(Fit.MM$diag.var[EX,]),
d = as.numeric(colnames(cd4)))
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyfun)
library(refund)
library(ggplot2)
library(reshape2)
source("../function/quadWeights.R")
source("../function/fpca.tfd.R")
temp_tfd = load("../data/temp_tfd.RData")
handw_tfd= load("../data/handw_tfd.RData")
DTI = refund::DTI
dti = with(refund::DTI,
data.frame(id = ID, sex = sex, pasat = pasat,
case = factor(ifelse(case, "MS", "control")))) %>% as.tbl %>%
mutate(cca = tfd(DTI$cca, seq(0,1, l = 93), signif = 2) %>%
tfd(arg = seq(0,1,l = 93)),
rcst = tfd(DTI$rcst, seq(0, 1, l = 55), signif = 3))
fit.cca = fpca.tfd(data = dti, col = cca)
fit.mu = data.frame(mu = fit.cca$mu,
n = 1:ncol(fit.cca$Yhat))
fit.basis = data.frame(phi = fit.cca$efunctions, #the FPC basis functions.
n = 1:ncol(fit.cca$Yhat))
## plot estimated mean function
ggplot(fit.mu, aes(x = n, y = mu)) + geom_path() + theme_bw()
## plot the first two estimated basis functions
fit.basis.m = melt(fit.basis, id = 'n')
ggplot(subset(fit.basis.m, variable %in% c('phi.1', 'phi.2')), aes(x = n,
y = value, group = variable, color = variable)) + geom_path() + theme_bw()
data(cd4)
# CD4 cell counts for 366 subjects between months -18 and 42 since seroconversion. Each subject's observations are contained in a single row.
# subject * weeks
cd4_tfd = cd4 %>%
tfd()
cd4_df = data_frame(cd4_tfd, id = 1:366) %>%
select(cd4 = cd4_tfd, everything())
fit.cd4 = cd4_df %>%
fpca.tfd(data =., col = cd4)
fit.mu = data.frame(mu = fit.cd4$mu,
n = 1:ncol(fit.cd4$Yhat))
fit.basis = data.frame(phi = fit.cd4$efunctions, #the FPC basis functions.
n = 1:ncol(fit.cd4$Yhat))
## for one subject, examine curve estimate, pointwise and simultaneous itervals
EX = 1
EX.MM = data.frame(fitted = Fit.MM$Yhat[EX,],
ptwise.UB = Fit.MM$Yhat[EX,] + 1.96 * sqrt(Fit.MM$diag.var[EX,]),
ptwise.LB = Fit.MM$Yhat[EX,] - 1.96 * sqrt(Fit.MM$diag.var[EX,]),
simul.UB = Fit.MM$Yhat[EX,] + Fit.MM$crit.val[EX] * sqrt(Fit.MM$diag.var[EX,]),
simul.LB = Fit.MM$Yhat[EX,] - Fit.MM$crit.val[EX] * sqrt(Fit.MM$diag.var[EX,]),
d = as.numeric(colnames(cd4)))
## plot estimated mean function
ggplot(fit.mu, aes(x = n, y = mu)) + geom_path() + theme_bw()
## plot the first two estimated basis functions
fit.basis.m = melt(fit.basis, id = 'n')
ggplot(subset(fit.basis.m, variable %in% c('phi.1', 'phi.2')), aes(x = n,
y = value, group = variable, color = variable)) + geom_path() + theme_bw()
data(cd4)
# CD4 cell counts for 366 subjects between months -18 and 42 since seroconversion. Each subject's observations are contained in a single row.
# subject * weeks
cd4_tfd = cd4 %>%
tfd()
cd4_df = data_frame(cd4_tfd, id = 1:366) %>%
select(cd4 = cd4_tfd, everything())
fit.cd4 = cd4_df %>%
fpca.tfd(data =., col = cd4)
Fit.mu = data.frame(mu = Fit.MM$mu,
d = as.numeric(colnames(cd4)))
data(cd4)
# CD4 cell counts for 366 subjects between months -18 and 42 since seroconversion. Each subject's observations are contained in a single row.
# subject * weeks
fit.cd4 = fpca.tfd(data = cd4_df, col = cd4_tfd, var = TRUE, simul = TRUE)
cd4_tfd = cd4 %>%
tfd()
cd4_df = data_frame(cd4_tfd)
data(cd4)
# CD4 cell counts for 366 subjects between months -18 and 42 since seroconversion. Each subject's observations are contained in a single row.
# subject * weeks
fit.cd4 = fpca.tfd(data = cd4_df, col = cd4_tfd, var = TRUE, simul = TRUE)
fit.mu = data.frame(mu = fit.cd4$mu,
n = 1:ncol(fit.cd4$Yhat))
fit.basis = data.frame(phi = fit.cd4$efunctions, #the FPC basis functions.
n = 1:ncol(fit.cd4$Yhat))
## for one subject, examine curve estimate, pointwise and simultaneous itervals
ex = 1
ex.cd4 = data.frame(fitted = fit.cd4$Yhat[ex,],
ptwise.UB = fit.cd4$Yhat[ex,] + 1.96 * sqrt(fit.cd4$diag.var[ex,]),
ptwise.LB = fit.cd4$Yhat[ex,] - 1.96 * sqrt(fit.cd4$diag.var[ex,]),
simul.UB = fit.cd4$Yhat[ex,] + fit.cd4$crit.val[ex] * sqrt(fit.cd4$diag.var[ex,]),
simul.LB = fit.cd4$Yhat[ex,] - fit.cd4$crit.val[ex] * sqrt(fit.cd4$diag.var[ex,]),
n = 1:ncol(fit.cd4$Yhat))
## plot data for one subject, with curve and interval estimates
ex.cd4.m = melt(ex.cd4, id = 'n')
## plot data for one subject, with curve and interval estimates
ex.cd4.m = melt(ex.cd4, id = 'n')
ggplot(ex.cd4.m, aes(x = n, y = value, group = variable, color = variable, linetype = variable)) +
geom_path() +
scale_linetype_manual(values = c(fitted = 1, ptwise.UB = 2,
ptwise.LB = 2, simul.UB = 3, simul.LB = 3)) +
scale_color_manual(values = c(fitted = 1, ptwise.UB = 2,
ptwise.LB = 2, simul.UB = 3, simul.LB = 3)) +
labs(x = 'Months since seroconversion', y = 'Total CD4 Cell Count')
## plot estimated mean function
ggplot(fit.mu, aes(x = n, y = mu)) + geom_path()
## plot the first two estimated basis functions
fit.basis.m = melt(fit.basis, id = 'n')
ggplot(subset(fit.basis.m, variable %in% c('phi.1', 'phi.2')), aes(x = n,
y = value, group = variable, color = variable)) + geom_path()
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyfun)
library(refund)
library(ggplot2)
library(reshape2)
temp_tfd = load("../data/temp_tfd.RData")
handw_tfd= load("../data/handw_tfd.RData")
DTI = refund::DTI
dti = with(refund::DTI,
data.frame(id = ID, sex = sex, pasat = pasat,
case = factor(ifelse(case, "MS", "control")))) %>% as.tbl %>%
mutate(cca = tfd(DTI$cca, seq(0,1, l = 93), signif = 2) %>%
tfd(arg = seq(0,1,l = 93)),
rcst = tfd(DTI$rcst, seq(0, 1, l = 55), signif = 3))
data(cd4)
cd4_tfd = cd4 %>%
tfd()
cd4_df = data_frame(cd4_tfd)
source("../function/quadWeights.R")
source("../function/fpca.tfd.R")
# DTI
fit.cca = fpca.tfd(data = dti, col = cca)
fit.mu = data.frame(mu = fit.cca$mu,
n = 1:ncol(fit.cca$Yhat))
fit.basis = data.frame(phi = fit.cca$efunctions, #the FPC basis functions.
n = 1:ncol(fit.cca$Yhat))
## plot estimated mean function
ggplot(fit.mu, aes(x = n, y = mu)) + geom_path() + theme_bw()
## plot the first two estimated basis functions
fit.basis.m = melt(fit.basis, id = 'n')
ggplot(subset(fit.basis.m, variable %in% c('phi.1', 'phi.2')), aes(x = n,
y = value, group = variable, color = variable)) + geom_path() + theme_bw()
fit.cd4 = fpca.tfd(data = cd4_df, col = cd4_tfd, var = TRUE, simul = TRUE)
fit.mu = data.frame(mu = fit.cd4$mu,
n = 1:ncol(fit.cd4$Yhat))
fit.basis = data.frame(phi = fit.cd4$efunctions, #the FPC basis functions.
n = 1:ncol(fit.cd4$Yhat))
## for one subject, examine curve estimate, pointwise and simultaneous itervals
ex = 1
ex.cd4 = data.frame(fitted = fit.cd4$Yhat[ex,],
ptwise.UB = fit.cd4$Yhat[ex,] + 1.96 * sqrt(fit.cd4$diag.var[ex,]),
ptwise.LB = fit.cd4$Yhat[ex,] - 1.96 * sqrt(fit.cd4$diag.var[ex,]),
simul.UB = fit.cd4$Yhat[ex,] + fit.cd4$crit.val[ex] * sqrt(fit.cd4$diag.var[ex,]),
simul.LB = fit.cd4$Yhat[ex,] - fit.cd4$crit.val[ex] * sqrt(fit.cd4$diag.var[ex,]),
n = 1:ncol(fit.cd4$Yhat))
## plot data for one subject, with curve and interval estimates
ex.cd4.m = melt(ex.cd4, id = 'n')
## plot data for one subject, with curve and interval estimates
ex.cd4.m = melt(ex.cd4, id = 'n')
ggplot(ex.cd4.m, aes(x = n, y = value, group = variable, color = variable, linetype = variable)) +
geom_path() +
scale_linetype_manual(values = c(fitted = 1, ptwise.UB = 2,
ptwise.LB = 2, simul.UB = 3, simul.LB = 3)) +
scale_color_manual(values = c(fitted = 1, ptwise.UB = 2,
ptwise.LB = 2, simul.UB = 3, simul.LB = 3)) +
labs(x = 'Months since seroconversion', y = 'Total CD4 Cell Count')
## plot estimated mean function
ggplot(fit.mu, aes(x = n, y = mu)) + geom_path()
## plot the first two estimated basis functions
fit.basis.m = melt(fit.basis, id = 'n')
ggplot(subset(fit.basis.m, variable %in% c('phi.1', 'phi.2')), aes(x = n,
y = value, group = variable, color = variable)) + geom_path()
source("../function/ols_cs_tfd.R")
dti["pasat"] = DTI$pasat
dti.ols = ols_cs_tfd(cca ~ pasat, data = dti, Kt = 10)
models = c("dti.ols")
intercepts = sapply(models, function(u) get(u)$beta.hat[1,])
slopes = sapply(models, function(u) get(u)$beta.hat[2,])
plot.dat = melt(intercepts); colnames(plot.dat) = c("grid", "method", "value")
ggplot(plot.dat, aes(x = grid, y = value, group = method, color = method)) +
geom_path() + theme_bw()
plot.dat = melt(slopes); colnames(plot.dat) = c("grid", "method", "value")
ggplot(plot.dat, aes(x = grid, y = value, group = method, color = method)) +
geom_path() + theme_bw()
dti_testing = dti
dti_testing["cca"] = dti$cca %>%
as.data.frame() %>%
spread(key = arg, value = value) %>%
select(-id) %>%
as.matrix()
dti_cca = dti_testing$cca %>% as.data.frame()
DTI_cca = DTI$cca %>% as.data.frame()
rownames(dti_cca) = rownames(DTI_cca)
colnames(dti_cca) = colnames(DTI_cca)
dti_cca %>% is.na() %>% sum() #0
DTI_cca %>% is.na() %>% sum() #36
Gibbs_bayes = bayes_fosr(cca ~ pasat, data = DTI, Kt = 10, est.method = "Gibbs", cov.method = "FPCA", N.iter = 500, N.burn = 200)
gibbs = gibbs_cs_fpca(cca ~ pasat, data = DTI, Kt = 10, N.iter = 500, N.burn = 200)
source("../function/gibbs_cs_fpca_tfd.R")
gibbs_dti = gibbs_cs_fpca_tfd(cca ~ pasat, data = dti, Kt = 10, N.iter = 500, N.burn = 200)
source("../function/gibbs_cs_wish_tfd.R")
gibbs_dti_wish = gibbs_cs_wish_tfd(cca ~ pasat, data = dti, Kt = 10, N.iter = 500, N.burn = 200)
gibbs_dti_wish = gibbs_dti_wish = gibbs_cs_wish_tfd(cca ~ pasat, data = dti, Kt = 10, N.iter = 500, N.burn = 200)
models = c("dti.ols", "gibbs_dti", "gibbs_dti_wish")
intercepts = sapply(models, function(u) get(u)$beta.hat[1,])
slopes = sapply(models, function(u) get(u)$beta.hat[2,])
plot.dat = melt(intercepts); colnames(plot.dat) = c("grid", "method", "value")
ggplot(plot.dat, aes(x = grid, y = value, group = method, color = method)) +
geom_path() + theme_bw() + ylab("intercept")
plot.dat = melt(slopes); colnames(plot.dat) = c("grid", "method", "value")
ggplot(plot.dat, aes(x = grid, y = value, group = method, color = method)) +
geom_path() + theme_bw() + ylab("slope")
dti_testing = dti
dti_testing["cca"] = dti$cca %>%
as.data.frame() %>%
spread(key = arg, value = value) %>%
select(-id) %>%
as.matrix()
dti_cca = dti_testing$cca %>% as.data.frame()
DTI_cca = DTI$cca %>% as.data.frame()
rownames(dti_cca) = rownames(DTI_cca)
colnames(dti_cca) = colnames(DTI_cca)
dti_cca %>% is.na() %>% sum() #0
DTI_cca %>% is.na() %>% sum() #36
dti %>%
ggplot(aes(y = cca, color = factor(id))) +
geom_spaghetti(alpha = .3) + xlab("days") + theme(legend.position="none") + ggtitle("FA tract profiles from the corpus callosum")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(refund)
library(reshape2)
library(tidyfun)
library(ggplot2)
DTI = refund::DTI
dti = with(refund::DTI,
data.frame(id = ID, sex = sex,
case = factor(ifelse(case, "MS", "control")))) %>% as.tbl %>%
mutate(cca = tfd(DTI$cca, seq(0,1, l = 93), signif = 2) %>%
tfd(arg = seq(0,1,l = 93)),
rcst = tfd(DTI$rcst, seq(0, 1, l = 55), signif = 3))
dti %>%
head()
pandoc_version()
library(rmarkdown)
if (pandoc_available())
cat("pandoc", as.character(pandoc_version()), "is available!\n")
pandoc_version()
